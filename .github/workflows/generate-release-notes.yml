name: Generate Release Notes

on:
  push:
    tags:
      - 'v*'
    branches:
      - master
      - release/*
  pull_request:
    branches:
      - master
      - release/*

permissions:
  contents: write
  pull-requests: write

jobs:
  release-notes:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: stable
      
      - name: Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}

      - name: Check for cargo-semver-checks in cache
        id: check_semver
        run: |
          if [ -x "$CARGO_HOME/bin/cargo-semver-checks" ]; then
            echo "cargo-semver-checks found in cache"
            echo "SEMVER_INSTALLED=true" >> $GITHUB_ENV
          else
            echo "cargo-semver-checks not found in cache"
            echo "SEMVER_INSTALLED=false" >> $GITHUB_ENV
          fi

      - name: Install cargo-semver-checks
        if: env.SEMVER_INSTALLED == 'false'
        run: cargo install cargo-semver-checks --locked

      - name: Run release-please
        uses: googleapis/release-please-action@v4
        with:
          release-type: rust
          token: ${{ secrets.GITHUB_TOKEN }}
          skip-github-pull-request: true
          skip-github-release: true

      - name: Get release version
        id: get_version
        run: |
          BRANCH="${GITHUB_REF##*/}"
          echo "GITHUB_REF: $GITHUB_REF"
          echo "Extracted BRANCH: $BRANCH"
          if [[ "$BRANCH" == "master" ]]; then
            VERSION="master"
          elif [[ "$BRANCH" == "release/"* ]]; then
            VERSION="${BRANCH#release/}"
          elif [[ "$BRANCH" == "develop" ]]; then
            VERSION="develop"
          elif [[ "$BRANCH" == "merge" ]]; then
            VERSION="merge"
          else
            VERSION="unknown"
          fi
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "RELEASE_TAG=v$VERSION" >> $GITHUB_ENV # Define RELEASE_TAG

      - name: Upload release notes artifact
        if: env.VERSION != 'unknown' # only upload if version is known
        run: |
          echo "Release notes artifact for version $VERSION"
          mkdir -p release_notes
          
          # Générer les notes de version avec release-please et les capturer
          RELEASE_NOTES=$(npx release-please --release-type rust --package-name . --dry-run | awk '/^---$/,/^---$/' | sed '1d;$d')
          echo "$RELEASE_NOTES" > release_notes/release_notes.md
          
          # Si la sortie de release-please est vide, créer un contenu par défaut
          if [ -z "$RELEASE_NOTES" ]; then
            echo "# Release Notes for $VERSION" > release_notes/release_notes.md
            echo "No significant changes for this release." >> release_notes/release_notes.md
          fi
          
          # Créer un fichier contenant la version
          echo "$VERSION" > release_notes/version.txt
          
          tar -czvf release_notes.tar.gz release_notes
          echo "RELEASE_NOTES_PATH=$GITHUB_WORKSPACE/release_notes.tar.gz" >> $GITHUB_ENV # Define RELEASE_NOTES_PATH
        
        # Utilisez upload-artifact pour rendre l'archive disponible pour d'autres jobs/workflows
      - name: Upload artifact
        if: env.VERSION != 'unknown'
        uses: actions/upload-artifact@v4
        with:
          name: release-notes-${{ env.VERSION }}
          path: ${{ env.RELEASE_NOTES_PATH }}